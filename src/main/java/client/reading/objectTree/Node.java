package client.reading.objectTree;

import client.reading.generators.Generator;
import client.reading.readers.OnlineReader;
import common.storedClasses.annotations.AutoGenerated;
import common.storedClasses.annotations.Boundaries;
import common.storedClasses.annotations.NotNull;

import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Modifier;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * class that is node of object tree
 */
public class Node {
    /**
     * classes that would be read directly
     */
    public static List<Class<?>> leavesClasses = Arrays.asList(Boolean.class, Integer.class, Float.class, String.class, Double.class, Long.class, Short.class);
    /**
     * name of field represented by this node
     */
    private final String name;
    /**
     * type of field/object represented by this node
     */
    private final Class<?> type;
    /**
     * Fields of object, represented by this node
     */
    private final List<Node> fields = new ArrayList<>();
    /**
     * generator of object, represented by this node
     */
    private Generator objectGenerator;
    /**
     * lowerBound of object represented by this Node
     */
    private BigDecimal lowerBound = null;
    /**
     * upperBound of object represented by this Node
     */
    private BigDecimal upperBound = null;
    /**
     * true if object, represented by this node can be null
     */
    private boolean nullable = false;

    /**
     * @param type - class, represented by this node
     * @param name - name of object, represented by this node
     */
    public Node(Class<?> type, String name) {
        this.type = type;
        this.name = name;
    }

    /**
     * @param type - type of object, which generator will be returned
     * @return Generator
     */
    private static Generator getGenerator(Class<?> type) {
        try {
            return (Generator) type.getMethod("getGenerator").invoke(null);
        } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * generates object tree
     *
     * @param type class, which is root of generated object tree
     * @param name name of object, that would be root of object tree
     * @return generated object tree
     */
    public static Node generateTree(Class<?> type, String name) {
        Node root = new Node(type, name);
        root.setObjectGenerator(getGenerator(type));
        create(root);
        return root;
    }

    /**
     * @param node  -- node, which bounds will be set
     * @param field -- field, represented by node
     */
    private static void setBounds(Node node, Field field) {
        var b = field.getAnnotation(Boundaries.class);
        BigDecimal l = null, u = null;
        if (b != null) {
            l = new BigDecimal(b.lowerBound());
            u = new BigDecimal(b.upperBound());
        }
        if (l == null || b.lowerBound().equals("")) {
            if (field.getType() == Long.class || field.getType() == long.class)
                l = BigDecimal.valueOf(Long.MIN_VALUE);
            if (field.getType() == Float.class || field.getType() == float.class)
                l = BigDecimal.valueOf(Float.MIN_VALUE);
            if (field.getType() == Integer.class || field.getType() == int.class)
                l = BigDecimal.valueOf(Integer.MIN_VALUE);
            if (field.getType() == Short.class || field.getType() == short.class)
                l = BigDecimal.valueOf(Short.MIN_VALUE);
        }
        if (u == null || b.upperBound().equals("")) {
            if (field.getType() == Long.class || field.getType() == long.class)
                u = BigDecimal.valueOf(Long.MAX_VALUE);
            if (field.getType() == Float.class || field.getType() == float.class)
                u = BigDecimal.valueOf(Float.MAX_VALUE);
            if (field.getType() == Integer.class || field.getType() == int.class)
                u = BigDecimal.valueOf(Integer.MAX_VALUE);
            if (field.getType() == Short.class || field.getType() == short.class)
                u = BigDecimal.valueOf(Short.MAX_VALUE);
        }
        node.setLowerBound(l);
        node.setUpperBound(u);
    }

    /**
     * @param root -- root of object tree
     */
    private static void create(Node root) {
        for (var field : root.getType().getDeclaredFields()) {
            if (field.isAnnotationPresent(AutoGenerated.class) || Modifier.isStatic(field.getModifiers())) continue;

            field.setAccessible(true);
            Node next = new Node(field.getType(), field.getName());

            next.setNullable(!field.isAnnotationPresent(NotNull.class) && !field.getType().isPrimitive());
            if (field.isAnnotationPresent(Boundaries.class) || OnlineReader.numbers.contains(field.getType())) {
                setBounds(next, field);
            }
            root.addField(next);
            if (field.getType().isEnum() || leavesClasses.contains(field.getType()) || field.getType().isPrimitive()) {
                continue;
            }

            next.setObjectGenerator(getGenerator(next.getType()));
            create(next);

        }

    }

    /**
     * sets nullable
     *
     * @param nullable -- boolean value
     */
    private void setNullable(boolean nullable) {
        this.nullable = nullable;
    }

    /**
     * adds field to fields
     *
     * @param field -- Node value
     */
    private void addField(Node field) {
        fields.add(field);
    }

    /**
     * @return List of Fields (related Nodes)
     */
    public List<Node> getFields() {
        return fields;
    }

    /**
     * @return name of this Node
     */
    public String getName() {
        return this.name;
    }

    /**
     * @return class represented by this Node
     */
    public Class<?> getType() {
        return type;
    }

    /**
     * @return lowerBound of this Node
     */
    public BigDecimal getLowerBound() {
        return this.lowerBound;
    }

    /**
     * sets lowerBound
     *
     * @param lowerBound -- BigDecimal value
     */
    private void setLowerBound(BigDecimal lowerBound) {
        this.lowerBound = lowerBound;
    }

    /**
     * @return upperBound of this Node
     */
    public BigDecimal getUpperBound() {
        return this.upperBound;
    }

    /**
     * sets upperBound
     *
     * @param upperBound -- BigDecimal value
     */
    private void setUpperBound(BigDecimal upperBound) {
        this.upperBound = upperBound;
    }

    /**
     * @return Generator of object represented by this Node
     */
    public Generator getObjectGenerator() {
        return objectGenerator;
    }

    /**
     * @param obj -- generator of object represented by this node
     */
    private void setObjectGenerator(Generator obj) {
        this.objectGenerator = obj;
    }

    /**
     * @return true, if object, represented by this Node, can be null
     */
    public boolean ifNullable() {
        return nullable;
    }

    @Override
    public String toString() {
        StringBuilder res = new StringBuilder();
        res.append(objectGenerator);
        res.append("\n");
        for (var x : fields) {
            res.append("\t").append(x.toString());
        }
        return res.toString();
    }
}